---
comment: True
counter: True
---

# 搜索求解

!!! abstract
    人工智能基础第 5 周课程内容

    参考：

    - 《人工智能导论：模型与算法》- 吴飞

## 搜索算法基础
- 评价指标
    - 完备性：能否找到解（不一定最优）
    - 最优性：能否保证找到的第一个解是最优解
    - 时间复杂度（通过扩展的结点数量衡量）
    - 空间复杂度（通过同时记录的结点数量衡量）
- 搜索算法框架
    ```text
    F <- {根节点}
    while F != ∅ do
        n <- pick_from(F)
        F <- F - {n}
        if goal_test(n) then
            return n.path
        end
        F <- F ∪ successor_nodes(n)
    end
    ```
    - pick_from 决定扩展结点的顺序，successor_nodes 决定哪些节点可被放入边缘集合（fringe set，也叫开表，open list）以在后面扩展（expand）
    - 每次从边缘集合中取出最上层（最浅）的结点时是广度优先搜索（breadth first search，BFS）
    - 每次从边缘集合中取出最下层（最深）的结点时是深度优先搜索（depth first search，DFS）
    - 放弃扩展部分结点的做法称为剪枝（pruning）

## 启发式搜索
- 利用一些能够辅助算法做出决策的额外信息的搜索算法称为启发式搜索（heuristic search），或有信息搜索（informed search）
- 提供的这些辅助信息称为启发信息
- 启发信息通常形式化为一个关于结点的函数 $h(n)$，其用于估计结点 $n$ 距离达到目标还需付出多少代价，这个函数称为启发函数（heuristic function）
    - 启发函数通常是非负的
    - 常见用法是用来更改前面的 pick_from 函数来规定挑选结点的顺序
- 对于任意结点 $n$，决定了搜索算法扩展结点 $n$ 的优先度的函数 $f(n)$ 称为评价函数（evaluation function）
    - 评价函数值越小，被挑选的优先级越高
    - 深度优先搜索中 $f(n)$ 可被定义为该结点深度的倒数
    - 广度优先搜索中 $f(n)$ 可被定义为该结点深度

### 贪婪最佳优先搜索
- 即 greedy best-first search，GBFS
- 优先扩展距离目标近的结点，即令 $f(n) = h(n)$
- 不排除环路的贪婪最佳优先搜索算法是不完备的
- 排除环路的贪婪最佳优先搜索是完备的，但不一定最优
- 最坏情况下的时间复杂度和空间复杂度均为 $O(b^m)$
    - $b$ 为分支因子（每个结点最大的分支数目）
    - $m$ 为最大深度，也就是搜索树中路径的最大可能长度

### A* 搜索
- 贪婪最佳优先搜索算法的问题是没有考虑从初始结点到扩展结点所需的代价
- A* 算法把从初始结点到当前结点的路径代价在评价函数中进行了考虑
- 令 $f(n) = g(n) + h(n)$，其中 $g(n)$ 为从初始结点到结点 $n$ 的路径代价
- 每次从边缘集合中扩展的结点并非总是当前结点的相邻后继结点
- 良好的启发函数需要满足的性质
    - 可容性（admissible）：对于任意结点 $n$，$h(n)$ 的值不会超过从结点 $n$ 到目标结点的最佳路径代价
    - 一致性（consistency）：对于任意结点 $n$，如果从结点 $n$ 到目标结点的最佳路径经过结点 $n'$，则 $h(n) \leq c(n, n') + h(n')$，其中 $c(n, n')$ 为从结点 $n$ 到结点 $n'$ 的路径代价
    - 满足一致性一定满足可容性
- A* 算法完备的条件
    - 搜索树中分支数量有限，即每个结点的后继结点数量是有限的
    - 单步代价的下届是一个正数
    - 启发函数有下届
- 启发函数满足一致性时，A* 算法是最优的

## 对抗搜索
- 智能体不唯一，解决信息确定、全局可观察、轮流行动、输赢收益零和的博弈问题，求解这样问题的算法称为对抗搜索（adversarial search）或博弈搜索（game search）
- 智能体会选择最大化自身利益、最小化对手利益的策略
- 形式化描述：
    - 状态：状态 $s$ 包括当前游戏局面和当前行动的智能体，初始状态 $s_0$ 为游戏开始时的状态。$\mathrm{player}(s)$ 表示状态 $s$ 下行动的智能体
    - 动作：动作是指 $\mathrm{player}(s)$ 在当前局面下可以采取的操作 $a$，记动作集合为 $\mathrm{actions}(s)$
    - 状态转移：状态转移函数 $s' = \mathrm{result}(s, a)$ 表示在状态 $s$ 下采取动作 $a$ 后的下一个状态
    - 终局状态测试：终局状态测试函数 $\mathrm{terminal\_test}(s)$ 用于测试游戏是否在状态 $s$ 下结束
    - 终局得分：终局得分函数 $\mathrm{utility}(s, p)$ 表示在状态 $s$ 下玩家 $p$ 的得分
        - 对于二人零和博弈，只需要记录其中一人的终局得分即可

### 最大最小搜索
- 最大最小搜索（minimax search）是求解对抗搜索问题的基本算法
- 该算法假设两名玩家在决策时总是理性地倾向于最大化自己的得分（最小化对方得分）
- 算法过程
    - 假设以最大化得分为目标的玩家为 MAX，以最小化得分为目标的玩家为 MIN
    - 某一层由 MAX 玩家行动，则其会选择得分最大的子树进行行动
    - 某一层由 MIN 玩家行动，则其会选择得分最小的子树进行行动
    - 递归地进行上述过程，直到达到终局状态
    - （子树的得分由所有它的子树的得分取最大或最小得到）

$$
\mathrm{minimax}(s) = \begin{cases}
\mathrm{utility}(s) & \text{if terminal\_test(}s\text{)} \\
\max_{a \in \mathrm{actions}(s)} \mathrm{minimax}(\mathrm{result}(s, a)) & \text{if player(}s\text{) = MAX} \\
\min_{a \in \mathrm{actions}(s)} \mathrm{minimax}(\mathrm{result}(s, a)) & \text{if player(}s\text{) = MIN}
\end{cases}
$$

- 最大最小搜索的时间复杂度为 $O(b^m)$，空间复杂度为 $O(bm)$

### Alpha-Beta 剪枝
- 如果搜索树极大，则最大最小搜索的开销巨大，无法在合理时间内返回结果
- Alpha-Beta 剪枝算法的思想如下：

    $$
    \begin{align*}
    \mathrm{minimax}(s_0) &= \max(\min(3, 9, 10), \min(2, x, y), \min(10, 5, 1))\\
    &= \max(3, \min(2, x, y), 1)
    \end{align*}
    $$

    - 上式中 $\min(2, x, y)$ 肯定小于 2，而外面一层求最大值又有 3 比它大
    - 所以就没有必要去搜索 $x, y$ 对应的子树得到具体的 $x, y$ 值，可以将这两个动作剪枝掉


